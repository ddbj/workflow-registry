{"content":"version 1.0\n\nimport \"AlignAndCall.wdl\" as AlignAndCall\n\n#import \"https://api.firecloud.org/ga4gh/v1/tools/mitochondria:AlignAndCall/versions/23/plain-WDL/descriptor\" as AlignAndCall\n\nworkflow MitochondriaPipeline {\n\n  meta {\n    description: \"Takes in an hg38 bam or cram and outputs VCF of SNP/Indel calls on the mitochondria.\"\n    allowNestedInputs: true\n  }\n\n  input {\n    File wgs_aligned_input_bam_or_cram\n    File wgs_aligned_input_bam_or_cram_index\n    String contig_name = \"chrM\"\n\n    # Read length used for optimization only. If this is too small CollectWgsMetrics might fail, but the results are not\n    # affected by this number. Default is 151.\n    Int? max_read_length\n\n    # Full reference is only requred if starting with a CRAM (BAM doesn't need these files)\n    File? ref_fasta\n    File? ref_fasta_index\n    File? ref_dict\n\n    File mt_dict\n    File mt_fasta\n    File mt_fasta_index\n    File mt_amb\n    File mt_ann\n    File mt_bwt\n    File mt_pac\n    File mt_sa\n    File blacklisted_sites\n    File blacklisted_sites_index\n\n    #Shifted reference is used for calling the control region (edge of mitochondria reference).\n    #This solves the problem that BWA doesn't support alignment to circular contigs.\n    File mt_shifted_dict\n    File mt_shifted_fasta\n    File mt_shifted_fasta_index\n    File mt_shifted_amb\n    File mt_shifted_ann\n    File mt_shifted_bwt\n    File mt_shifted_pac\n    File mt_shifted_sa\n\n    File shift_back_chain\n\n    File control_region_shifted_reference_interval_list\n    File non_control_region_interval_list\n\n    String? requester_pays_project\n    File? gatk_override\n    String? gatk_docker_override\n    String? m2_extra_args\n    String? m2_filter_extra_args\n    Float? vaf_filter_threshold\n    Float? f_score_beta\n    Float? verifyBamID\n    Boolean compress_output_vcf = false\n\n    #Optional runtime arguments\n    Int? preemptible_tries\n  }\n\n  parameter_meta {\n    wgs_aligned_input_bam_or_cram: \"Full WGS hg38 bam or cram\"\n    out_vcf: \"Final VCF of mitochondrial SNPs and INDELs\"\n    vaf_filter_threshold: \"Hard threshold for filtering low VAF sites\"\n    f_score_beta: \"F-Score beta balances the filtering strategy between recall and precision. The relative weight of recall to precision.\"\n    contig_name: \"Name of mitochondria contig in reference that wgs_aligned_input_bam_or_cram is aligned to\"\n  }\n\n  call SubsetBamToChrM {\n    input:\n      input_bam = wgs_aligned_input_bam_or_cram,\n      input_bai = wgs_aligned_input_bam_or_cram_index,\n      contig_name = contig_name,\n      ref_fasta = ref_fasta,\n      ref_fasta_index = ref_fasta_index,\n      ref_dict = ref_dict,\n      requester_pays_project = requester_pays_project,\n      gatk_override = gatk_override,\n      gatk_docker_override = gatk_docker_override,\n      preemptible_tries = preemptible_tries\n  }\n\n  call RevertSam {\n    input:\n      input_bam = SubsetBamToChrM.output_bam,\n      preemptible_tries = preemptible_tries\n  }\n\n  String base_name = basename(SubsetBamToChrM.output_bam, \".bam\")\n\n\n  call AlignAndCall.AlignAndCall as AlignAndCall {\n    input:\n      unmapped_bam = RevertSam.unmapped_bam,\n      base_name = base_name,\n      mt_dict = mt_dict,\n      mt_fasta = mt_fasta,\n      mt_fasta_index = mt_fasta_index,\n      mt_amb = mt_amb,\n      mt_ann = mt_ann,\n      mt_bwt = mt_bwt,\n      mt_pac = mt_pac,\n      mt_sa = mt_sa,\n      blacklisted_sites = blacklisted_sites,\n      blacklisted_sites_index = blacklisted_sites_index,\n      mt_shifted_dict = mt_shifted_dict,\n      mt_shifted_fasta = mt_shifted_fasta,\n      mt_shifted_fasta_index = mt_shifted_fasta_index,\n      mt_shifted_amb = mt_shifted_amb,\n      mt_shifted_ann = mt_shifted_ann,\n      mt_shifted_bwt = mt_shifted_bwt,\n      mt_shifted_pac = mt_shifted_pac,\n      mt_shifted_sa = mt_shifted_sa,\n      shift_back_chain = shift_back_chain,\n      gatk_override = gatk_override,\n      gatk_docker_override = gatk_docker_override,\n      m2_extra_args = m2_extra_args,\n      m2_filter_extra_args = m2_filter_extra_args,\n      vaf_filter_threshold = vaf_filter_threshold,\n      f_score_beta = f_score_beta,\n      verifyBamID = verifyBamID,\n      compress_output_vcf = compress_output_vcf,\n      max_read_length = max_read_length,\n      preemptible_tries = preemptible_tries\n  }\n\n  # This is a temporary task to handle \"joint calling\" until Mutect2 can produce a GVCF.\n  # This proivdes coverage at each base so low coverage sites can be considered ./. rather than 0/0.\n  call CoverageAtEveryBase {\n    input:\n      input_bam_regular_ref = AlignAndCall.mt_aligned_bam,\n      input_bam_regular_ref_index = AlignAndCall.mt_aligned_bai,\n      input_bam_shifted_ref = AlignAndCall.mt_aligned_shifted_bam,\n      input_bam_shifted_ref_index = AlignAndCall.mt_aligned_shifted_bai,\n      shift_back_chain = shift_back_chain,\n      control_region_shifted_reference_interval_list = control_region_shifted_reference_interval_list,\n      non_control_region_interval_list = non_control_region_interval_list,\n      ref_fasta = mt_fasta,\n      ref_fasta_index = mt_fasta_index,\n      ref_dict = mt_dict,\n      shifted_ref_fasta = mt_shifted_fasta,\n      shifted_ref_fasta_index = mt_shifted_fasta_index,\n      shifted_ref_dict = mt_shifted_dict\n  }\n  \n  call SplitMultiAllelicSites {\n    input:\n      input_vcf = AlignAndCall.out_vcf,\n      base_name = base_name,\n      ref_fasta = mt_fasta,\n      ref_fasta_index = mt_fasta_index,\n      ref_dict = mt_dict,\n      gatk_override = gatk_override,\n      gatk_docker_override = gatk_docker_override,\n      preemptible_tries = preemptible_tries\n  }\n\n  output {\n    File subset_bam = SubsetBamToChrM.output_bam\n    File subset_bai = SubsetBamToChrM.output_bai\n    File mt_aligned_bam = AlignAndCall.mt_aligned_bam\n    File mt_aligned_bai = AlignAndCall.mt_aligned_bai\n    File out_vcf = AlignAndCall.out_vcf\n    File out_vcf_index = AlignAndCall.out_vcf_index\n    File split_vcf = SplitMultiAllelicSites.split_vcf\n    File split_vcf_index = SplitMultiAllelicSites.split_vcf_index\n    File input_vcf_for_haplochecker = AlignAndCall.input_vcf_for_haplochecker\n    File duplicate_metrics = AlignAndCall.duplicate_metrics\n    File coverage_metrics = AlignAndCall.coverage_metrics\n    File theoretical_sensitivity_metrics = AlignAndCall.theoretical_sensitivity_metrics\n    File contamination_metrics = AlignAndCall.contamination_metrics\n    File base_level_coverage_metrics = CoverageAtEveryBase.table\n    Int mean_coverage = AlignAndCall.mean_coverage\n    Float median_coverage = AlignAndCall.median_coverage\n    String major_haplogroup = AlignAndCall.major_haplogroup\n    Float contamination = AlignAndCall.contamination\n  }\n}\n\ntask SubsetBamToChrM {\n  input {\n    File input_bam\n    File input_bai\n    String contig_name\n    String basename = basename(basename(input_bam, \".cram\"), \".bam\")\n    String? requester_pays_project\n    File? ref_fasta\n    File? ref_fasta_index\n    File? ref_dict\n\n    File? gatk_override\n    String? gatk_docker_override\n\n    # runtime\n    Int? preemptible_tries\n  }\n  Float ref_size = if defined(ref_fasta) then size(ref_fasta, \"GB\") + size(ref_fasta_index, \"GB\") + size(ref_dict, \"GB\") else 0\n  Int disk_size = ceil(size(input_bam, \"GB\") + ref_size) + 20\n\n  meta {\n    description: \"Subsets a whole genome bam to just Mitochondria reads\"\n  }\n  parameter_meta {\n    ref_fasta: \"Reference is only required for cram input. If it is provided ref_fasta_index and ref_dict are also required.\"\n    input_bam: {\n      localization_optional: true\n    }\n    input_bai: {\n      localization_optional: true\n    }\n  }\n  command <<<\n    set -e\n    export GATK_LOCAL_JAR=~{default=\"/root/gatk.jar\" gatk_override}\n\n    gatk PrintReads \\\n      ~{\"-R \" + ref_fasta} \\\n      -L ~{contig_name} \\\n      --read-filter MateOnSameContigOrNoMappedMateReadFilter \\\n      --read-filter MateUnmappedAndUnmappedReadFilter \\\n      ~{\"--gcs-project-for-requester-pays \" + requester_pays_project} \\\n      -I ~{input_bam} \\\n      --read-index ~{input_bai} \\\n      -O ~{basename}.bam\n  >>>\n  runtime {\n    memory: \"3 GB\"\n    disks: \"local-disk \" + disk_size + \" HDD\"\n    docker: select_first([gatk_docker_override, \"us.gcr.io/broad-gatk/gatk:4.1.7.0\"])\n    preemptible: select_first([preemptible_tries, 5])\n  }\n  output {\n    File output_bam = \"~{basename}.bam\"\n    File output_bai = \"~{basename}.bai\"\n  }\n}\n\ntask RevertSam {\n  input {\n    File input_bam\n    String basename = basename(input_bam, \".bam\")\n\n    # runtime\n    Int? preemptible_tries\n  }\n  Int disk_size = ceil(size(input_bam, \"GB\") * 2.5) + 20\n\n  meta {\n    description: \"Removes alignment information while retaining recalibrated base qualities and original alignment tags\"\n  }\n  parameter_meta {\n    input_bam: \"aligned bam\"\n  }\n  command {\n    java -Xmx1000m -jar /usr/gitc/picard.jar \\\n    RevertSam \\\n    INPUT=~{input_bam} \\\n    OUTPUT_BY_READGROUP=false \\\n    OUTPUT=~{basename}.bam \\\n    VALIDATION_STRINGENCY=LENIENT \\\n    ATTRIBUTE_TO_CLEAR=FT \\\n    ATTRIBUTE_TO_CLEAR=CO \\\n    SORT_ORDER=queryname \\\n    RESTORE_ORIGINAL_QUALITIES=false\n  }\n  runtime {\n    disks: \"local-disk \" + disk_size + \" HDD\"\n    memory: \"2 GB\"\n    docker: \"us.gcr.io/broad-gotc-prod/genomes-in-the-cloud:2.4.2-1552931386\"\n    preemptible: select_first([preemptible_tries, 5])\n  }\n  output {\n    File unmapped_bam = \"~{basename}.bam\"\n  }\n}\n\ntask CoverageAtEveryBase {\n  input {\n    File input_bam_regular_ref\n    File input_bam_regular_ref_index\n    File input_bam_shifted_ref\n    File input_bam_shifted_ref_index\n    File shift_back_chain\n    File control_region_shifted_reference_interval_list\n    File non_control_region_interval_list\n    File ref_fasta\n    File ref_fasta_index\n    File ref_dict\n    File shifted_ref_fasta\n    File shifted_ref_fasta_index\n    File shifted_ref_dict\n\n    Int? preemptible_tries\n  }\n  Int disk_size = ceil(size(input_bam_regular_ref, \"GB\") + size(input_bam_shifted_ref, \"GB\") + size(ref_fasta, \"GB\") * 2) + 20\n\n  meta {\n    description: \"Remove this hack once there's a GVCF solution.\"\n  }\n  command <<<\n    set -e\n\n    java -jar /usr/gitc/picard.jar CollectHsMetrics \\\n      I=~{input_bam_regular_ref} \\\n      R=~{ref_fasta} \\\n      PER_BASE_COVERAGE=non_control_region.tsv \\\n      O=non_control_region.metrics \\\n      TI=~{non_control_region_interval_list} \\\n      BI=~{non_control_region_interval_list} \\\n      COVMAX=20000 \\\n      SAMPLE_SIZE=1\n\n    java -jar /usr/gitc/picard.jar CollectHsMetrics \\\n      I=~{input_bam_shifted_ref} \\\n      R=~{shifted_ref_fasta} \\\n      PER_BASE_COVERAGE=control_region_shifted.tsv \\\n      O=control_region_shifted.metrics \\\n      TI=~{control_region_shifted_reference_interval_list} \\\n      BI=~{control_region_shifted_reference_interval_list} \\\n      COVMAX=20000 \\\n      SAMPLE_SIZE=1\n\n    R --vanilla <<CODE\n      shift_back = function(x) {\n        if (x < 8570) {\n          return(x + 8000)\n        } else {\n          return (x - 8569)\n        }\n      }\n\n      control_region_shifted = read.table(\"control_region_shifted.tsv\", header=T)\n      shifted_back = sapply(control_region_shifted[,\"pos\"], shift_back)\n      control_region_shifted[,\"pos\"] = shifted_back\n\n      beginning = subset(control_region_shifted, control_region_shifted[,'pos']<8000)\n      end = subset(control_region_shifted, control_region_shifted[,'pos']>8000)\n\n      non_control_region = read.table(\"non_control_region.tsv\", header=T)\n      combined_table = rbind(beginning, non_control_region, end)\n      write.table(combined_table, \"per_base_coverage.tsv\", row.names=F, col.names=T, quote=F, sep=\"\\t\")\n\n    CODE\n  >>>\n  runtime {\n    disks: \"local-disk \" + disk_size + \" HDD\"\n    memory: \"1200 MB\"\n    docker: \"us.gcr.io/broad-gotc-prod/genomes-in-the-cloud:2.4.2-1552931386\"\n    preemptible: select_first([preemptible_tries, 5])\n  }\n  output {\n    File table = \"per_base_coverage.tsv\"\n  }\n}\n\ntask SplitMultiAllelicSites {\n  input {\n    File ref_fasta\n    File ref_fasta_index\n    File ref_dict\n    File input_vcf\n    String base_name\n    Int? preemptible_tries\n    File? gatk_override\n    String? gatk_docker_override\n  }\n\n  String output_vcf = base_name + \".final.split.vcf\"\n  String output_vcf_index = output_vcf + \".idx\"\n\n  command {\n    set -e\n    export GATK_LOCAL_JAR=~{default=\"/root/gatk.jar\" gatk_override}\n    gatk LeftAlignAndTrimVariants \\\n      -R ~{ref_fasta} \\\n      -V ~{input_vcf} \\\n      -O ~{output_vcf} \\\n      --split-multi-allelics \\\n      --dont-trim-alleles \\\n      --keep-original-ac\n  }\n  output {\n    File split_vcf = \"~{output_vcf}\"\n    File split_vcf_index = \"~{output_vcf}\"\n  }\n  runtime {\n      docker: select_first([gatk_docker_override, \"us.gcr.io/broad-gatk/gatk:4.1.7.0\"])\n      memory: \"3 MB\"\n      disks: \"local-disk 20 HDD\"\n      preemptible: select_first([preemptible_tries, 5])\n  } \n}\n","checksum":[{"checksum":"94c5cb5a5b8f264b69793f06e841ec5ce300a20eab425e0d774cdc075a8ec7b4","type":"sha256"}],"url":"https://zenodo.org/api/files/d539b0a0-5bce-41f1-9938-d9b97ca3f523/MitochondriaPipeline.wdl"}